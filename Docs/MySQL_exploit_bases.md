# Les bases de MySQL 

## Introduction

SQL (Structured Query Language) est un langage de requête structuré utilisé pour communiquer avec une base de données relationnelle. Il est utilisé pour effectuer des opérations sur les données stockées dans une base de données ou pour modifier les données existantes. Il est principalement utilisé pour la gestion des données dans les systèmes de gestion de bases de données relationnelles (SGBDR), tels que MySQL, Oracle, Sybase, Microsoft SQL Server, PostgreSQL et SQLite.

Le serveur gère toutes les instructions relatives à la base de données, telles que la création, l'édition et l'accès aux données. Il reçoit et gère ces demandes et communique à l'aide du protocole MySQL. L'ensemble du processus peut être décomposé en plusieurs étapes :

* MySQL crée une base de données pour stocker et manipuler les données, en définissant les relations entre chaque table.
* Les clients formulent des requêtes en utilisant des instructions spécifiques en SQL.
* Le serveur répond au client en lui fournissant les informations demandées

MySQL peut fonctionner sur différentes plateformes, qu'il s'agisse de Linux ou de Windows. Il est couramment utilisé comme base de données dorsale pour de nombreux sites web importants et constitue un composant essentiel de la pile LAMP, qui comprend : Linux, Apache, MySQL et PHP.

### Explication des mots clés MySQL

#### Schéma

Dans MySQL, physiquement, un schéma est synonyme de base de données. Vous pouvez remplacer le mot-clé "DATABASE" par "SCHEMA" dans la syntaxe SQL de MySQL, par exemple en utilisant CREATE SCHEMA au lieu de CREATE DATABASE. Il est important de comprendre cette relation car d'autres produits de base de données font une distinction. Par exemple, dans le produit Oracle Database, un schéma ne représente qu'une partie d'une base de données : les tables et autres objets appartenant à un seul utilisateur.

#### Les Hashs :

Les hachages sont, très simplement, le produit d'un algorithme cryptographique qui transforme une entrée de longueur variable en une sortie de longueur fixe.

Dans MySQL, les hachages peuvent être utilisés de différentes manières, par exemple pour indexer des données dans une table de hachage. Chaque hachage possède un identifiant unique qui sert de pointeur vers les données d'origine. Cela permet de créer un index beaucoup plus petit que les données d'origine, ce qui permet de rechercher et d'accéder aux valeurs de manière plus efficace

Cependant, les données que nous allons extraire sont des hachages de mots de passe, qui sont simplement un moyen de stocker des mots de passe qui ne sont pas en clair.

## Enumeration

### Intro sur l'énumération MySQL

MySQL n'est probablement pas le premier point d'appel lorsque vous obtenez des informations initiales sur le serveur. Vous pouvez, essayer de forcer les mots de passe des comptes par défaut si vous n'avez vraiment pas d'autres informations ; cependant, dans la plupart des scénarios CTF, il est peu probable que ce soit la voie que vous soyez censé suivre. En règle générale, vous aurez obtenu des informations d'identification initiales en énumérant d'autres services, que vous pourrez ensuite utiliser pour énumérer et exploiter le service MySQL.

### Ports de base SQL

Le port de base SQL est le port 3306. C'est du TCP/IP.

### Packet nécessaire

Pour l'énumération de MySQL, il faut un client MySQL. Le plus légé est **mysql-client**.
Mais il existe aussi **mysql-workbench** qui est plus complet.

### Outils utilisés pour l'énumation MySQL

On va utiliser Metasploit pour l'énumération de MySQL. On va utiliser le module **auxiliary/scanner/mysql/mysql_login**. Mais il existe aussi des outils comme **SQLMap**, **SQLNinja** et **SQLPing**. Ou encore le script **mysql-enum** de **nmap** : [scitp infos](https://nmap.org/nsedoc/scripts/mysql-enum.html) ou [exploit db](https://www.exploit-db.com/exploits/23081)

### Connexion à MySQL

Pour se connecter à MySQL, on utilise la commande suivante :

```bash
mysql -u <user> -p <password> -h <host> -P <port>
```

### Utilisation de Metasploit

Supposons qu'on ai récupéré le couple USER:PASSWORD, on va utiliser le module **auxiliary/scanner/mysql/mysql_login** de Metasploit.

```bash
msf5 > use auxiliary/scanner/mysql/mysql_login
msf5 auxiliary(scanner/mysql/mysql_login) > set RHOSTS
RHOSTS =>
msf5 auxiliary(scanner/mysql/mysql_login) > set PASSWORD
PASSWORD =>
msf5 auxiliary(scanner/mysql/mysql_login) > set USERNAME
USERNAME =>
msf5 auxiliary(scanner/mysql/mysql_login) > run
```
Par défaut l'option `SQL` est `select version()`. Donc cela va nous retourner la version de MySQL.
Mais on peut changer pour `show databases` pour afficher les bases de données.

Plus d'infos sur le module : [ici](https://www.infosecmatter.com/metasploit-module-library/?mm=auxiliary/scanner/mysql/mysql_login)


## Exploitation

## Dump des bases de données

Pour dump les bases de données on va utiliser le module **mysql_schemadump** de Metasploit.

```bash
msf5 > use auxiliary/scanner/mysql/mysql_schemadump
msf5 auxiliary(scanner/mysql/mysql_schemadump) > set RHOSTS
RHOSTS =>
msf5 auxiliary(scanner/mysql/mysql_schemadump) > set PASSWORD
PASSWORD =>
msf5 auxiliary(scanner/mysql/mysql_schemadump) > set USERNAME
USERNAME =>
msf5 auxiliary(scanner/mysql/mysql_schemadump) > run
```

## Dump des hashs des mots de passe

Pour dump les hashs des mots de passe on va utiliser le module **mysql_hashdump** de Metasploit.

```bash
msf5 > use auxiliary/scanner/mysql/mysql_hashdump
msf5 auxiliary(scanner/mysql/mysql_hashdump) > set RHOSTS
...
msf5 auxiliary(scanner/mysql/mysql_hashdump) > run
```

### Dump des hashs des mots de passe sur sqlite manuellement

Pour dump les hashs des mots de passe, supposons que l'on a accès au fichier '.db' qui n'est autre que la base de donnée d'un site internet. Il suffit de la télécharger et de l'ouvrir avec un outil comme **sqlite3**. 
Exemple :
```bash
sqlite3 <database>
```

On va afficher les tables :

```bash
.tables
```
On va afficher les informations sur les tables trouvées :
    
```bash
PRAGMA table_info(<nom de la table>);
```

On va afficher les données de la table :

```bash
SELECT * FROM <nom de la table>;
```


